<?xml version="1.0" encoding="UTF-8"?>
<chapter id="jmx">
  <title>JMX support</title>

  <para>JMX is a standard Java API for making beans accessible to others in terms of management and remote configuration. JMX is the short term for Java Management Extensions
  and is often used in JEE application servers to manage bean attributes and operations from outside (e.g. another JVM). A managed bean server hosts multiple managed beans for JMX access.
  Remote connections to JMX can be realized with RMI (Remote method invocation) capabilities.</para>

  <para>Citrus is able to connect to JMX managed beans as client and server. As a client Citrus can invoke managed bean operations and read write managed bean attributes. As a server
  Citrus is able to expose managed beans as mbean server. Clients can access those Citrus managed beans and get proper response objects as result. Doing so you can use the JVM platform
  managed bean server or some RMI registry for providing remote access.</para>

  <note>
    <para>The JMX components in Citrus are kept in a separate Maven module. So you should check that the module
      is available as Maven dependency in your project</para>

    <programlisting>&lt;dependency&gt;
  &lt;groupId&gt;com.consol.citrus&lt;/groupId&gt;
  &lt;artifactId&gt;citrus-jmx&lt;/artifactId&gt;
  &lt;version&gt;2.5-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;</programlisting>

    <para>As usual Citrus provides a customized jmx configuration schema that
      is used in Spring configuration files. Simply include the citrus-jmx namespace in the configuration XML files as follows.</para>

    <programlisting>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xmlns:citrus=&quot;http://www.citrusframework.org/schema/config&quot;
      xmlns:citrus-jmx=&quot;http://www.citrusframework.org/schema/jmx/config&quot;
      xsi:schemaLocation=&quot;
      http://www.springframework.org/schema/beans
      http://www.springframework.org/schema/beans/spring-beans.xsd
      http://www.citrusframework.org/schema/config
      http://www.citrusframework.org/schema/config/citrus-config.xsd
      http://www.citrusframework.org/schema/jmx/config
      http://www.citrusframework.org/schema/jmx/config/citrus-jmx-config.xsd&quot;&gt;

      [...]

      &lt;/beans&gt;</programlisting>

    <para>Now you are ready to use the customized Http configuration elements with the
      citrus-jmx namespace prefix.</para>
  </note>

  <para>Next sections describe the JMX message support in Citrus in more detail.</para>

  <section id="jmx-client">
    <title>JMX client</title>

    <para>On the client side we want to call some managed bean by either accessing managed attributes with read/write or by invoking a managed bean operation.
    For proper mbean server connectivity we should specify a client component for JMX that sends out mbean invocation calls.</para>

    <programlisting>&lt;citrus-jmx:client id=&quot;jmxClient&quot;
      server-url=&quot;platform&quot;/&gt;</programlisting>

    <para>The client component specifies the target managed bean server that we want to connect to. In this example we are using the JVM platform mbean server.
    This means we are able to access all JVM managed beans such as Memory, Threading and Logging. In addition to that we can access all custom managed beans that were
    exposed to the platform mbean server.</para>

    <para>In most cases you may want to access managed beans on a different JVM or application server. So we need some remote connection to the foreign mbean server.</para>

    <programlisting>&lt;citrus-jmx:client id=&quot;jmxClient&quot;
      server-url=&quot;service:jmx:rmi:///jndi/rmi://localhost:1099/jmxrmi&quot;
      username=&quot;user&quot;
      password=&quot;s!cr!t&quot;
      auto-reconnect=&quot;true&quot;
      delay-on-reconnect=&quot;5000&quot;/&gt;</programlisting>

    <para>In this example above we connect to a remote mbean server via RMI using the default RMI registry <emphasis>localhost:1099</emphasis> and the service name <emphasis>jmxrmi</emphasis>.
    Citrus is able to handle different remote transport protocols. Just define those in the <emphasis>server-url</emphasis>.</para>

    <para>Now that we have setup the client component we can use it in a test case to access a managed bean.</para>

    <programlisting>&lt;send endpoint=&quot;jmxClient&quot;&gt;
    &lt;message&gt;
        &lt;payload&gt;
            &lt;mbean-invocation xmlns=&quot;http://www.citrusframework.org/schema/jmx/message&quot;&gt;
              &lt;mbean&gt;java.lang:type=Memory&lt;/mbean&gt;
              &lt;attribute name=&quot;Verbose&quot;/&gt;
            &lt;/mbean-invocation&gt;
        &lt;/payload&gt;
    &lt;/message&gt;
&lt;/send&gt;</programlisting>

    <para>As you can see we just used a normal send action referencing the jmx client component that we have just added. The message payload is a XML representation of the managed bean access. This
    is a special Citrus XML representation. Citrus will convert this XML payload to the actuel managed bean access. In the example above we try to access a managed bean with object name <emphasis>java.lang:type=Memory</emphasis>.
    The object name is defined in JMX specification and consists of a key <emphasis>java.lang:type</emphasis> and a value <emphasis>Memory</emphasis>. So we identify the managed bean on the server by its type.</para>

    <para>Now that we have access to the managed bean we can read its managed attributes such as <emphasis>Verbose</emphasis>. This is a boolean type attribute so the mbean invocation result will be a respective Boolean object. We
    can validate the managed bean attribute access in a receive action.</para>

    <programlisting>&lt;receive endpoint=&quot;jmxClient&quot;&gt;
    &lt;message&gt;
        &lt;payload&gt;
            &lt;mbean-result xmlns=&quot;http://www.citrusframework.org/schema/jmx/message&quot;&gt;
              &lt;object type=&quot;java.lang.Boolean&quot; value=&quot;false&quot;/&gt;
            &lt;/mbean-result&gt;
        &lt;/payload&gt;
    &lt;/message&gt;
&lt;/receive&gt;</programlisting>

    <para>In the sample above we receive the mbean result and expect a <emphasis>java.lang.Boolean</emphasis> object return value.
    The return value content is also validated within the mbean result payload.</para>

    <para>Some managed bean attributes might also be settable for us. So wen can define the attribute access as write operation by specifying a value in the send action payload.</para>

    <programlisting>&lt;send endpoint=&quot;jmxClient&quot;&gt;
    &lt;message&gt;
        &lt;payload&gt;
            &lt;mbean-invocation xmlns=&quot;http://www.citrusframework.org/schema/jmx/message&quot;&gt;
              &lt;mbean&gt;java.lang:type=Memory&lt;/mbean&gt;
              &lt;attribute name=&quot;Verbose&quot; value=&quot;true&quot; type=&quot;java.lang.Boolean&quot;/&gt;
            &lt;/mbean-invocation&gt;
        &lt;/payload&gt;
    &lt;/message&gt;
&lt;/send&gt;</programlisting>

    <para>Now we have write access to the managed attribute <emphasis>Verbose</emphasis>. We do specify the value and its type <emphasis>java.lang.Boolean</emphasis>. This is how we can set attribute values on managed beans.</para>

    <para>Last not least we are able to access managed bean operations.</para>

    <programlisting>&lt;send endpoint=&quot;jmxClient&quot;&gt;
    &lt;message&gt;
        &lt;payload&gt;
            &lt;mbean-invocation xmlns=&quot;http://www.citrusframework.org/schema/jmx/message&quot;&gt;
              &lt;mbean&gt;com.consol.citrus.jmx.mbean:type=HelloBean&lt;/mbean&gt;
              &lt;operation&gt;sayHello&gt;/operation&gt;
                &gt;parameter&gt;
                  &gt;param type="java.lang.String" value="Hello JMX!"/&gt;
                &gt;/parameter&gt;
            &lt;/mbean-invocation&gt;
        &lt;/payload&gt;
    &lt;/message&gt;
&lt;/send&gt;</programlisting>

    <para>In the example above we access a custom managed bean and invoke its operation <emphasis>sayHello</emphasis>. We are also using operation parameters for the invocation. This should call the managed bean operation and return its result if any as usual.</para>

    <para>This completes the basic JMX managed bean access as client. Now we also want to discuss the server side were Citrus is able to provide managed beans for others</para>
  </section>

  <section id="jmx-server">
    <title>JMX server</title>

    <para>The server side is always a little bit more tricky because we need to simulate custom managed bean access as a server. First of all Citrus provides a server component that specifies the connection properties for clients such as ports and mbean object names.</para>

    <programlisting>&lt;citrus-jmx:server id=&quot;jmxServer&quot;
      server-url=&quot;service:jmx:rmi:///jndi/rmi://localhost:1099/jmxrmi&quot;
    &lt;citrus-jmx:mbeans>
        &lt;citrus-jmx:mbean type="com.consol.citrus.jmx.mbean.HelloBean"/>
        &lt;citrus-jmx:mbean type="com.consol.citrus.jmx.mbean.NewsBean" objectDomain="com.consol.citrus.news" objectName="name=News"/>
    &lt;/citrus-jmx:mbeans>
&lt;/citrus-jmx:server></programlisting>

    <para>As usual we define a <emphasis>server-url</emphasis> that controls the JMX connector access to the mbean server. We could also use <emphasis>platform</emphasis> as url in order to use the JVM platform mbean server. In this example above we open a RMI connector
    for clients using the registry <emphasis>localhost:1099</emphasis> and the service name <emphasis>jmxrmi</emphasis>. Now clients can connect to the Citrus mbean server. As nested configuration elements we also define the managed beans that should be exposed for access.
    Here two managed bean are added <emphasis>HelloBean</emphasis> and <emphasis>NewsBean</emphasis>. Citrus will use the package name and class name for proper object name construction. So the first managed bean is accessible using the object name
    <emphasis>com.consol.citrus.jmx.mbean:type=HelloBean</emphasis>. The second managed bean definition uses a custom object domain and name value. So the <emphasis>NewsBean</emphasis> will be accessible with <emphasis>com.consol.citrus.news:name=News</emphasis>.</para>

    <para>When clients try to find the managed beans they have to use these object names accordingly. Other object names will be rejected with managed bean not found error. Now we can use the server component in a test case to receive some incoming managed bean access.</para>

    <programlisting>&lt;receive endpoint=&quot;jmxServer&quot;&gt;
    &lt;message&gt;
        &lt;payload&gt;
            &lt;mbean-invocation xmlns=&quot;http://www.citrusframework.org/schema/jmx/message&quot;&gt;
              &lt;mbean&gt;com.consol.citrus.jmx.mbean:type=HelloBean&lt;/mbean&gt;
              &lt;operation&gt;sayHello&lt;/operation&gt;
              &gt;parameter&gt;
                &gt;param type="java.lang.String" value="Hello JMX!"/&gt;
              &gt;/parameter&gt;
            &lt;/mbean-invocation&gt;
        &lt;/payload&gt;
    &lt;/message&gt;
&lt;/receive&gt;</programlisting>

    <para>In this very first example we expect a managed bean access to the bean <emphasis>com.consol.citrus.jmx.mbean:type=HelloBean</emphasis>. We further expect the operation <emphasis>sayHello</emphasis> to be called with respective parameter values. Now we have to define the
    operation result that will be returned to the calling client as operation result.</para>

    <programlisting>&lt;send endpoint=&quot;jmxServer&quot;&gt;
    &lt;message&gt;
        &lt;payload&gt;
          &lt;mbean-result xmlns=&quot;http://www.citrusframework.org/schema/jmx/message&quot;&gt;
            &lt;object type=&quot;java.lang.String&quot; value=&quot;Hello from JMX!&quot;/&gt;
          &lt;/mbean-result&gt;
        &lt;/payload&gt;
    &lt;/message&gt;
&lt;/send&gt;</programlisting>

    <para>The operation returns a String <emphasis>Hello from JMX!</emphasis>. This is how we can expect operation calls on managed beans. Now we already have seen that managed beans also expose attributes. The next example is handling incoming attribute read access.</para>

    <programlisting>&lt;receive endpoint=&quot;jmxServer&quot;&gt;
    &lt;message&gt;
        &lt;payload&gt;
            &lt;mbean-invocation xmlns=&quot;http://www.citrusframework.org/schema/jmx/message&quot;&gt;
              &lt;mbean&gt;com.consol.citrus.news:name=News&lt;/mbean&gt;
                &gt;attribute name="newsCount"/&gt;
            &lt;/mbean-invocation&gt;
        &lt;/payload&gt;
    &lt;/message&gt;
&lt;/receive&gt;

&lt;send endpoint=&quot;jmxServer&quot;&gt;
    &lt;message&gt;
        &lt;payload&gt;
          &lt;mbean-result xmlns=&quot;http://www.citrusframework.org/schema/jmx/message&quot;&gt;
            &lt;object type=&quot;java.lang.Integer&quot; value=&quot;100&quot;/&gt;
          &lt;/mbean-result&gt;
        &lt;/payload&gt;
    &lt;/message&gt;
&lt;/send&gt;</programlisting>

    <para>The receive action expects read access to the <emphasis>NewsBean</emphasis> attribute <emphasis>newsCount</emphasis> and returns a result object of type <emphasis>java.lang.Integer</emphasis>. This way we can expect all attribute access to our managed beans. Write operations
    will have a attribute value specified.</para>

    <para>This completes the JMX server capabilities with managed bean access on operations and attributes.</para>
  </section>

</chapter>
