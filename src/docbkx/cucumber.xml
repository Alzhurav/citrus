<?xml version="1.0" encoding="UTF-8"?>
<chapter id="cucumber">
    <title>Cucumber BDD support</title>

    <para>Behavior driven development (BDD) is becoming more and more popular these days. The idea of defining and describing the software behavior as basis
    for all tests in prior to translating those feature descriptions into executable tests is a very interesting approach because it includes the technical experts
    as well as the domain experts. With BDD the domain experts can easily read and verify the tests and the technical experts get a detailed description of what should happen
    in the test.</para>

    <para>The test scenario description most of the time follows the Gherkin syntax with a <emphasis>"Given-When-Then"</emphasis> structure. The Gherkin language is business readable and well known in BDD.</para>

    <para>There are lots of frameworks in the Java community that support BDD concepts. Citrus has dedicated support for the Cucumber framework because Cucumber is well suited for extensions and plugins.
    So with the Citrus and Cucumber integration you can write Gherkin syntax scenario and feature stories in order to execute the Citrus integration test capabilities. As usual we have a look at a first example.
    First lets see the Citrus cucumber dependency and XML schema definitions.</para>

    <note>
        <para>The Cucumber components in Citrus are kept in a separate Maven module. If not already done so you have to include the module
        as Maven dependency to your project</para>

        <programlisting>&lt;dependency&gt;
  &lt;groupId&gt;com.consol.citrus&lt;/groupId&gt;
  &lt;artifactId&gt;citrus-cucumber&lt;/artifactId&gt;
  &lt;version&gt;2.6-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;</programlisting>

        <para>Citrus provides a separate configuration namespace and schema definition for Cucumber related step definitions. Include this namespace into your Spring
        configuration in order to use the Citrus Cucumber configuration elements. The namespace URI and schema location are added to the
        Spring configuration XML file as follows.</para>
        
        <programlisting>&lt;spring:beans xmlns:spring=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns=&quot;http://www.citrusframework.org/schema/cucumber/testcase&quot;
       xsi:schemaLocation=&quot;
       http://www.springframework.org/schema/beans 
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.citrusframework.org/schema/cucumber/testcase
       http://www.citrusframework.org/schema/cucumber/testcase/citrus-cucumber-testcase.xsd&quot;&gt;
       
    [...]
    
&lt;/spring:beans&gt;</programlisting>
        
        <para>After that you are able to use customized Citrus XML elements in order to define the Spring beans.</para>
    </note>

    <section id="cucumber-integration">
        <title>Cucumber integration</title>

        <para>Cucumber is able to run tests with JUnit. The basic test case is an empty test which uses the respective JUnit runner implementation from cucumber.</para>

        <programlisting>@RunWith(Cucumber.class)
@CucumberOptions(
  glue = { "com.consol.citrus.cucumber", "my.company.features" },
  plugin = { "com.consol.citrus.cucumber.CitrusReporter" } )
public class MyFeatureIT {

}</programlisting>

        <para>The test case above uses the <emphasis>Cucumber</emphasis> JUnit test runner. In addition to that we give some options to the Cucumber execution. The glue option defines introduces Citrus glue code that is mandatory
        for combining Cucumber and Citrus capabilities. Therefore always include the <emphasis>com.consol.citrus.cucumber</emphasis> glue. Secondly we add the feature package that we now want to test <emphasis>my.company.features</emphasis>. This is the package
        where all scenario and feature stories and custom step definitions are located for the test run.</para>

        <para>Also important ith the Citrus reporter implementation. This class is responsible for printing the Citrus test summary. This reporter extends the default Cucumber reporter implementation so the default Cucumber report summaries are also printed
        with this <emphasis>CitrusReporter</emphasis>.</para>

        <para>That completes the JUnit class configuration. Now we are able to add feature stories and step definitions to the package <emphasis>my.company.features</emphasis>. So lets write a feature story <emphasis>echo.feature</emphasis>.</para>

        <programlisting>Feature: Echo service

  Scenario: Say hello
    Given My name is Citrus
    When I say hello to the service
    Then the service should return: "Hello, my name is Citrus!"

  Scenario: Say goodbye
    Given My name is Citrus
    When I say goodbye to the service
    Then the service should return: "Goodbye from Citrus!"</programlisting>

        <para>As you can see this story defines two scenarios with the Gherkin <emphasis>Given-When-Then</emphasis> syntax. Now we need to add step definitions that glue the story description to Citrus test actions. Lets do this in a new class <emphasis>EchoSteps</emphasis>.</para>

        <programlisting>public class EchoSteps {

    @CitrusResource
    protected TestDesigner designer;

    @Given("^My name is (.*)$")
    public void my_name_is(String name) {
        designer.variable("username", name);
    }

    @When("^I say hello.*$")
    public void say_hello() {
        designer.send("echoEndpoint")
          .messageType(MessageType.PLAINTEXT)
          .payload("Hello, my name is ${username}!");
    }

    @When("^I say goodbye.*$")
    public void say_goodbye() {
        designer.send("echoEndpoint")
          .messageType(MessageType.PLAINTEXT)
          .payload("Goodbye from ${username}!");
    }

    @Then("^the service should return: \"([^\"]*)\"$")
    public void verify_return(final String body) {
        designer.receive("echoEndpoint")
          .messageType(MessageType.PLAINTEXT)
          .payload("You just said: " + body);
    }

}</programlisting>

      <para>If we have a closer look at the step definition class we see that it is a normal POJO that uses a <emphasis>@CitrusResource</emphasis> annotated <emphasis>TestDesginer</emphasis>. The test designer is automatically injected by Citrus. This is done
      because we have included the citrus-cucumber glue in the Cucumber options before. Now we can write @Given, @When or @Then annotated methods that match the scenario descriptions in our story. Cucumber will automatically find matching methods and execute them.
      The methods add test actions to the test designer as we are used to it in normal Java DSL tests. At the end the test designer is automatically executed with the test logic.</para>

      <para>If you run the Cucumber test you will see the step execution and at the end the Citrus test case performs its actions. That is a first combination of Citrus and Cucumber BDD. The story descriptions are translated to test designer actions and we are able to
      run integration tests with behavior driven development. Great! In a next step we will use XML step definitions rather than coding the steps in Java DSL.</para>
    </section>
    
    <section id="cucumber-xml-steps">
      <title>Cucumber XML steps</title>

      <para>So far we have written some glue code in Java in order to translate.</para>

    </section>
</chapter>