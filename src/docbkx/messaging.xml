<?xml version="1.0" encoding="UTF-8"?>
<chapter id="messaging">
  <title>Messaging</title>

  <para>In one of the previous chapters we have discussed the basic test case structure as we introduced <emphasis>variables</emphasis> and
  <emphasis>test actions</emphasis>. The &lt;actions&gt; section contains a list of test actions that take place during the test case. 
  Each test action is executed in sequential order by default. Citrus offers several built-in test actions that the user can choose from to construct a complex
  testing workflow without having to code everything from scratch. In particular Citrus aims to provide all the test actions that you need as predefined components 
  ready for you to use. The goal is to minimize the coding effort for you so you can concentrate on the test logic itself. All available test actions are discussed 
  in the next sections.</para>
  
  <para>As sending and receiving messages is essential in integration testing of message-based architectures we will handle these actions in first place.
  But first of all lets have a look at the common message interface in Citrus:</para>
  
  <mediaobject>
    <imageobject role="fo">
      <imagedata align="center" width="200px" scale="100" fileref="figure_001.jpg" format="JPG" />
    </imageobject>
    
    <imageobject role="html">
      <imagedata align="center" display="block" fileref="figure_001.jpg" format="JPG" />
    </imageobject>
  </mediaobject>
  
  <para>A message consists of a message header (name-value pairs) and a message payload. Later in this document we will see how 
  a test constructs several messages with payload and header values. But first of all let's concentrate on sending and receiving 
  messages to/from various transports. Endpoint components play a significant role in this respect. The next figure shows a
  typical message sending endpoint component in Citrus:</para>
  
  <mediaobject>
    <imageobject role="fo">
      <imagedata align="center" width="450px" scale="100" fileref="figure_002.jpg" format="JPG" />
    </imageobject>
    
    <imageobject role="html">
      <imagedata align="center" display="block" fileref="figure_002.jpg" format="JPG" />
    </imageobject>
  </mediaobject>

  <para>The endpoint producer publishes messages to a destination. This destination can be a JMS queue/topic, a SOAP WebService endpoint, a Http URL, a FTP folder destination
  and many more. The producer just takes a previously defined message definition (header and payload) and sends it to the message destination.</para>
  
  <para>Similar to that Citrus defines the several endpoint consumer components to consume messages from destinations. This can be a simple subscription
  on message channels and JMS queues/topics. In case of SOAP WebServices and Http GET/POST things are more complicated as we have to provide a 
  server component that clients can connect to. We will handle this Http server related communication later in this document. For now
  a endpoint consumer component in its most simple way is defined like this:</para>
  
  <mediaobject>
    <imageobject role="fo">
      <imagedata align="center" width="450px" scale="100" fileref="figure_003.jpg" format="JPG" />
    </imageobject>
    
    <imageobject role="html">
      <imagedata align="center" display="block" fileref="figure_003.jpg" format="JPG" />
    </imageobject>
  </mediaobject>
  
  <para>In the next sections you will learn how a test case uses those endpoint components for producing and consuming messages.</para>
  
  <section id="message-sending">
    <title>Sending messages</title>

    <para>The &lt;send&gt; action publishes messages to a destination. The message transport which is used under the hood does not
    matter to the test case - for now. The test case simply defines the message contents and uses a predefined message sender components to actually 
    publish the constructed message to a destination. There are several message sender implementations in Citrus available representing different transport 
    protocols like JMS, SOAP, HTTP, TCP/IP and many more.</para>
     
    <para>Again the type of transport to use is not specified inside the test case but in the message sender definition. The separation of concerns (test case/message sender transport) 
    gives us a good flexibility of our test cases. The test case does not know anything about connection factories, queue names or endpoint urls, connection timeouts and so on. The transport 
    internals underneath a sending test action can change easily without affecting the test case definition. We will see later in this document how to create different message senders for 
    various transports in Citrus. For now we concentrate on constructing the message content to be sent.</para>
    
    <para>We assume that the message's payload will be plain XML format. Citrus uses XML as the default data format for message payload data. But Citrus is not limited to XML message format 
    though; you can always define other message data formats such as JSON, plain text, CSV. As XML is still a very popular message format in enterprise applications and message-based solution
    architectures we have this as a default format. Anyway Citrus works best on XML payloads and you will see a lot of example code in this document using XML. Finally let us have a look at a 
    first example how a sending action is defined in the test.</para>
    
    <para><emphasis>XML DSL</emphasis></para>
    <programlisting>&lt;testcase name=&quot;SendMessageTest&quot;&gt;
    &lt;description&gt;Basic send message example&lt;/description&gt;
    &lt;variables&gt;
        &lt;variable name=&quot;text&quot; value=&quot;Hello Citrus!&quot;/&gt;
        &lt;variable name=&quot;messageId&quot; value=&quot;Mx1x123456789&quot;/&gt;
    &lt;/variables&gt;
    &lt;actions&gt;
        &lt;send endpoint=&quot;helloServiceClient&quot;&gt;
            &lt;message&gt;
                &lt;payload&gt;
                    &lt;TestMessage&gt;
                        &lt;Body&gt;${text}&lt;/Body&gt;
                    &lt;/TestMessage&gt;
                &lt;/payload&gt;
            &lt;/message&gt;
            &lt;header&gt;
                &lt;element name=&quot;Operation&quot; value=&quot;sayHello&quot;/&gt;
                &lt;element name=&quot;MessageId&quot; value=&quot;${messageId}&quot;/&gt;
            &lt;/header&gt;
        &lt;/send&gt;
    &lt;/actions&gt;
&lt;/testcase&gt;</programlisting>
    
    <para>The sample uses both header and payload as message parts to send. In both parts you can use variable definitions
    (see <emphasis>${text}</emphasis> and <emphasis>${messageId}</emphasis>). So first of all let us recap what variables do.
    Test variables are defined at the very beginning of the test case and are valid throughout all actions that take place in
    the test. This means that actions can simply reference a variable by the expression <literal>${variable-name}</literal>.</para>
    
    <tip>
        <para>Use variables wherever you can! At least the important entities of a test should be defined as variables at the 
        beginning. The test case improves maintainability and flexibility when using variables.</para>
    </tip>
    
    <para>Now lets have a closer look at the sending action. The 'with' attribute might catch your attention first.
    This attribute references a message endpoint in Citrus configuration by name. As previously mentioned the message endpoint
    definition lives in a separate configuration file and contains the actual message transport settings. In this example the
    <emphasis>&quot;helloServiceClient&quot;</emphasis> is referenced which is a special client endpoint for sending out messages via
    HTTP for instance.</para>
    
    <para>The test case is not aware of any transport details, because it does not have to. The advantages are obvious: On the one hand multiple test
    cases can reference the message endpoint definition for better reuse. Secondly test cases are independent of message transport details.
    So connection factories, user credentials, endpoint uri values and so on are not present in the test case.</para>
    
    <para>In other words the <emphasis>&quot;endpoint&quot;</emphasis> attribute of the <emphasis>&lt;send&gt;</emphasis> element specifies
    which message endpoint definition to use and therefore where the message should go to. Once again all available message endpoints are
    configured in a separate Citrus configuration file. We will come to this later on. Be sure to always pick the right message endpoint type
    in order to publish your message to the right destination.</para>
    
    <para>If you do not like the XML language you can also use pure Java code to define the same test. In Java you would also make use of the message endpoint
    definition and reference this instance. The same test as shown above in Java DSL looks like this:</para>
    
    <para><emphasis>Java DSL</emphasis></para>
    <programlisting language="java">import org.testng.ITestContext;
import org.testng.annotations.Test;
import com.consol.citrus.annotations.CitrusTest;
import com.consol.citrus.dsl.TestNGCitrusTestBuilder;

@Test
public class SendMessageTest extends TestNGCitrusTestBuilder {

    @CitrusTest(name = "SendMessageTest")
    public void sendMessageTest() {
        description("Basic send message example");
    
        variable("text", "Hello Citrus!");
        variable("messageId", "Mx1x123456789");
    
        send("helloServiceClient")
            .payload("&lt;TestMessage&gt;" +
                        "&lt;Body&gt;${text}&lt;/Body&gt;" +
                    "&lt;/TestMessage&gt;")
            .header("Operation", "sayHello")
            .header("RequestTag", "${messageId}");
    }
}</programlisting>

    <para>Instead of using the XML tags for send we use methods from <emphasis>TestNGCitrusTestBuilder</emphasis> class. The same message endpoint
    is referenced within the send message action. The payload is constructed as plain Java character sequence which is a bit verbose. We will see
    later on how we can improve this. For now it is important to understand the combination of send test action and a message endpoints.</para>
    
    <tip>
        <para>It is good practice to follow naming conventions when defining names for message endpoints. The intended purpose of the message
        endpoint as well as the sending/receiving actor should be clear when choosing the name. For instance messageEndpoint1,
        messageEndpoint2 will not give you much hints to the purpose of the message endpoint.</para>
    </tip>
    
    <para>Now that the message sender pattern is clear we can concentrate on how to specify the message content to be sent. 
    There are several possibilities for you to define message content in Citrus:</para>
        
    <itemizedlist mark="opencircle">
        <listitem>
            <para><emphasis>message</emphasis>: This element constructs the message to be sent. There are several child elements available:</para>
            <itemizedlist mark="opencircle">
                <listitem>
                    <para><emphasis>payload</emphasis>: Nested XML payload as direct child node.</para>
                </listitem>
                <listitem>
                    <para><emphasis>data</emphasis>: Inline CDATA definition of the message payload</para>
                </listitem>
                <listitem>
                    <para><emphasis>resource</emphasis>: External file resource holding the message payload</para>
                    <para>The syntax would be: &lt;resource file="classpath:com/consol/citrus/messages/TestRequest.xml" /&gt;</para>
                    <para>The file path prefix indicates the resource type, so the file location is resolved either as file system resource (file:) 
                    or classpath resource (classpath:).</para>
                </listitem>
                <listitem>
                    <para><emphasis>element</emphasis>: Explicitly overwrite values in the XML message payload using XPath. You can replace message content 
                    with dynamic values before sending. Each &lt;element&gt; entry provides a &quot;path&quot; and &quot;value&quot; attribute. The &quot;path&quot; 
                    gives a XPath expression evaluating to a XML node element or attribute in the message. The &quot;value&quot; can be a variable expression or any other 
                    static value. Citrus will replace the value before sending the message.</para>
                </listitem>
            </itemizedlist>
        </listitem>
        <listitem>
            <para><emphasis>header</emphasis>: Defines a header for the message (e.g. JMS header information or SOAP header):</para>
            <itemizedlist mark="opencircle">
                <listitem>
                    <para><emphasis>element</emphasis>: Each header receives a &quot;name&quot; and &quot;value&quot;. The &quot;name&quot; will be the 
                    name of the header entry and &quot;value&quot; its respective value. Again the usage of variable expressions as value is supported here, too.</para>
                </listitem>
            </itemizedlist>
        </listitem>
    </itemizedlist>
    
    <para>The most important thing when dealing with sending actions is to prepare the message payload and header. You are able to construct the message payload either by 
    nested XML chil nodes (payload), as inline CDATA (&lt;data&gt;) or external file (&lt;resource&gt;). Before sending takes place you can explicitly overwrite some message
    values explicitly. You can think of overwriting specific message elements with variable values for instance. The example above uses the variable ${text} directly in the
    XML payload definition. In addition to that you can use XPath expressions for overwriting message contents before sending. The two approaches of overwriting message
    elements before sending can coexist simultaneously.</para>
     
    <para>The message header is part of our duty of defining proper messages, too. So Citrus uses name-value pairs like &quot;Operation&quot; and &quot;MessageId&quot; in the
    example above to set message header entries. Depending on what message endpoint is used and which message transport underneath the header values will be shipped in different ways.
    In JMS the headers go to the header section of the message, in Http we set mime headers accordingly, in SOAP we can access the SOAP header elements and so on. Citrus aims to do
    the hard work for you. So Citrus knows how to set headers on different message transports.</para>
    
    <note>
      <para>Sometimes the nested XML message payload elements may cause XSD schema validation rule violations. This is because of variable values not fitting the XSD schema rules
      for example. In this scenario you could also use simple CDATA sections as payload data. In this case you need to use the <literal>&lt;data&gt;</literal> element in contrast
      to the <literal>&lt;payload&gt;</literal> element that we have used in our examples so far.</para>

      <para>With this alternative you can skip the XML schema validation from your IDE at design time. Unfortunately you will loose the XSD auto completion features many XML editors
      offer when constructing your payload. See following example for usage explanation:</para>
      
      <programlisting>&lt;testcase name=&quot;sendMessageTest&quot;&gt;
    &lt;actions&gt;
        &lt;send endpoint=&quot;helloServiceClient&quot;&gt;
            &lt;message&gt;
                &lt;data&gt;
                    &lt;![CDATA[
                    &lt;hlo:HelloRequest xmlns:hlo=&quot;http://www.consol.de/schemas/samples/sayHello.xsd&quot;&gt;
                        &lt;hlo:Body&gt;Hello Citrus!&lt;/hlo:Body&gt;
                    &lt;/hlo:HelloRequest&gt;
                    ]]&gt;
                &lt;/data&gt;
            &lt;/message&gt;
            ...
        &lt;/send&gt;
    &lt;/actions&gt;
&lt;/testcase&gt;</programlisting>

      <para>This alternative works for receiving message actions, too. We will see this in the next sections.</para>
    </note>
    
    <para>This is basically how to send messages in Citrus. The test case is responsible for constructing the message content while the predefined message endpoint holds transport specific
    settings. Test cases reference endpoint components to publish messages to the outside world. The variable support in message payload and message header
    enables you to add dynamic values before sending out the message.</para>
  </section>
  
  <section id="message-receiving">
    <title>Receiving messages</title>

    <para>Now we have a look at the message receiving part inside the test. A simple example shows how it works.</para>
    
    <para><emphasis>XML DSL</emphasis></para>
    <programlisting>&lt;receive endpoint=&quot;helloServiceServer&quot;&gt;
    &lt;message&gt;
        &lt;payload&gt;
            &lt;TestMessage&gt;
                &lt;Body&gt;${text}&lt;/Body&gt;
            &lt;/TestMessage&gt;
        &lt;/payload&gt;
    &lt;/message&gt;
    &lt;header&gt;
        &lt;element name=&quot;Operation&quot; value=&quot;sayHello&quot;/&gt;
        &lt;element name=&quot;MessageId&quot; value=&quot;${messageId}&quot;/&gt;
    &lt;/header&gt;
&lt;/receive&gt;</programlisting>
    
    <para>If we recap the send action of the previous chapter we can identify some common mechanisms that apply for both
    sending and receiving actions. This time the test uses a predefined message server endpoint in order to receive the message.
    Again the test is not aware of the transport details such as JMS connections, endpoint uri, and so on. The message endpoint
    component encapsulates this information.</para>
    
    <para>Before we go into detail on validating the received message we have a quick look at the Java DSL variation for the
    receive action. The same receive action as above looks like this in Java DSL.</para>
    
    <para><emphasis>Java DSL</emphasis></para>
    <programlisting language="java">@CitrusTest
public void messagingTest() {
    receive("helloServiceServer")
        .payload("&lt;TestMessage&gt;" +
                    "&lt;Body&gt;${text}&lt;/Body&gt;" +
                "&lt;/TestMessage&gt;")
        .header("Operation", "sayHello")
        .header("MessageId", "${messageId}");
}</programlisting>
    
    <para>The receive action waits for a message to arrive. The whole test execution is stopped while waiting for the message. This is
    important to ensure the step by step test workflow processing. Of course you can specify message timeouts so the receiver will only
    wait a given amount of time before raising a timeout error. Following from that timeout exception the test case fails as the message
    did not arrive in time. Citrus defines default timeout settings for all message receiving tasks.</para>
    
    <para>In a good case scenario the message arrives in time and the content can be validated as a next step. This validation can be done
    in various ways. On the one hand you can specify a whole XML message that you expect as control template. In this case the received message
    structure is compared to the expected message content element by element. On the other hand you can use explicit element validation where only a
    small subset of message elements is included into validation.</para>
    
    <para>Besides the message payload Citrus will also perform validation on the received message header values. Test variable usage is 
    supported as usual during the whole validation process for payload and header checks.</para>
    
    <para>In general the validation component (validator) in Citrus works hand in hand with a message receiving component as the following
    figure shows:</para>
    
    <mediaobject>
      <imageobject role="fo">
        <imagedata align="center" display="block" fileref="figure_005.jpg" format="JPG" />
      </imageobject>
      
      <imageobject role="html">
        <imagedata align="center" display="block" fileref="figure_005.jpg" format="JPG" />
      </imageobject>
    </mediaobject>
   
    <para>The message receiving component passes the message to the validator where the individual validation steps are performed. Let us have a closer 
    look at the validation options and features step by step.</para>
    
    <section id="message-payload-validation">
        <title>Validate message content</title>
        
        <para>Once Citrus has received a message the tester can validate the message contents in various ways. First of all the tester can compare 
        the whole message payload to a predefined control message template.</para>
        
        <para>The receiving action offers following elements for control message templates:</para>
        <itemizedlist mark="opencircle">
            <listitem>
              <para><emphasis>&lt;payload&gt;</emphasis>: Defines the message payload as nested XML message template. The whole message payload is defined
              inside the test case.</para>
            </listitem>
            <listitem>
                <para><emphasis>&lt;data&gt;</emphasis>: Defines an inline XML message template as nested CDATA. Slightly different to the payload variation as
                we define the whole message payload inside the test case as CDATA section.</para>
            </listitem>
            <listitem>
                <para><emphasis>&lt;resource&gt;</emphasis>: Defines an expected XML message template via external file resources. This time the payload is loaded
                at runtime from the external file.</para>
            </listitem>
        </itemizedlist>
        
        <para>Both ways inline payload definition or external file resource give us a control message template that the test case expects to arrive. Citrus uses this
        control template for extended message comparison. All elements, namespaces, attributes and node values are validated in this comparison. When using XML message payloads
        Citrus will navigate through the whole XML structure validating each element and its content. Same with JSON payloads.</para>

        <para>Only in case received message and control message are equal to each other as expected the message validation will pass. In case differences occur Citrus gives
        detailed error messages and the test case fails.</para>
        
        <para>The control message template is not necessarily very static. Citrus supports various ways to add dynamic message content on the one side and on the other side Citrus can
        ignore some elements that are not part of message comparison (e.g. when generated content or timestamps are part of the message content). The tester can enrich the expected
        message template with test variables or ignore expressions so we get a more robust validation mechanism. We will talk about this in the next sections to come.</para>
        
        <para>When using the Citrus Java DSL you will face a verbose message payload definition. This is because Java does not support multiline character sequence values as Strings.
        We have to use verbose String concatenation when constructing XML message payload contents for instance. In addition to that reserved characters like quotes must be escaped
        and line breaks must be explicitly added. All these impediments let me suggest to use external file resources in Java DSL when dealing with large complex message payload data.
        Here is an example:</para>
        
        <para><emphasis>Java DSL</emphasis></para>
    <programlisting language="java">@CitrusTest
public void receiveMessageTest() {
    receive("helloServiceServer")
        .payload(new ClassPathResource("com/consol/citrus/message/data/TestRequest.xml"))
        .header("Operation", "sayHello")
        .header("MessageId", "${messageId}");
}</programlisting>
    </section>
    
    <section id="message-dynamic-validation">
        <title>Dynamic message values</title>
        
        <para>Some elements in our message payload might be of dynamic nature. Just think of generated identifiers or timestamps. Also we do not want to repeat the same static identifier several
        times in our test cases. This is the time where test variables and dynamic message element overwrite come in handy. The idea is simple. We want to overwrite a specific message element in our
        payload with a dynamic value. This can be done with XPath or inline variable declarations. Lets have a look at an example listing showing both ways:</para>
        
        <para><emphasis>XML DSL</emphasis></para>
        <programlisting>&lt;message&gt;
    &lt;payload&gt;
        &lt;TestMessage&gt;
            &lt;MessageId&gt;${messageId}&lt;/MessageId&gt;
            &lt;CreatedBy&gt;_&lt;/CreatedBy&gt;
            &lt;VersionId&gt;${version}&lt;/VersionId&gt;
        &lt;/TestMessage&gt;
    &lt;/payload&gt;
    &lt;element path=&quot;/TestMessage/CreatedBy&quot; value=&quot;${user}&quot;/&gt;
&lt;/message&gt;</programlisting>
        
        <para>The program listing above shows ways of setting variable values inside a message template. First of all you can
        simply place variable expressions inside the message (see how ${messageId} is used). In addition to that you can also use
        XPath expressions to explicitly overwrite message elements before validation.</para>
        
        <para><literal>&lt;element path=&quot;/TestMessage/CreatedBy&quot; value=&quot;${user}&quot;/&gt;</literal></para>
        
        <para>The XPath expression evaluates and searches for the right element in the message payload. The previously defined variable
        <emphasis>${user}</emphasis> replaces the element value. Of course this works with XML attributes too.</para>
        
        <para>Both ways via XPath or inline variable expressions are equal to each other. With respect to the complexity of XML namespaces and XPath you may
        find the inline variable expression more comfortable to use. Anyway feel free to choose the way that fits best for you. This is how we can add dynamic variable
        values to the control template in order to increase maintainability and robustness of message validation.</para>
        
        <tip>Validation matchers put validation mechanisms to a new level offering dynamic assertion statements for validation. Have a look at the possibilities with 
        assertion statements in <xref linkend="validation-matchers"/></tip>
    </section>
    
    <section id="message-validation-ignore">
        <title>Ignore message elements</title>
        
        <para>Some elements in the message payload might not apply for validation at all. Just think of communication timestamps an dynamic values inside a 
        message:</para>
        
        <para>The timestamp value in our next example will dynamically change from test run to test run and is hardly predictable for the tester, so lets ignore it in validation.</para>
        
        <para><emphasis>XML DSL</emphasis></para>
        <programlisting> &lt;message&gt;
    &lt;payload&gt;
        &lt;TestMessage&gt;
            &lt;MessageId&gt;${messageId}&lt;/MessageId&gt;
            &lt;Timestamp&gt;2001-12-17T09:30:47.0Z&lt;/Timestamp&gt;
            &lt;VersionId&gt;@ignore@&lt;/VersionId&gt;
        &lt;/TestMessage&gt;
    &lt;/payload&gt;
    &lt;ignore path=&quot;/TestMessage/Timestamp&quot;/&gt;
&lt;/message&gt;</programlisting>
        
        <para>Although we have given a static timestamp value in the payload data the element is ignored during validation as the ignore XPath expression matches the element. In addition to that
        we also ignored the version id element in this example. This time with an inline <emphasis>@ignore@</emphasis> expression. This is for those of you that do not like XPath. As a result the
        ignored message elements are automatically skipped when Citrus compares and validates message contents and do not break the test case.</para>
        
        <para>When using the Java DSL the <emphasis>@ignore@</emphasis> placeholder as well as XPath expressions can be used seamlessly. Here is an example of that:</para>
        
        <para><emphasis>Java DSL</emphasis></para>
    <programlisting language="java">@CitrusTest
public void receiveMessageTest() {
    receive("helloServiceServer")
        .payload(new ClassPathResource("com/consol/citrus/message/data/TestRequest.xml"))
        .header("Operation", "sayHello")
        .header("MessageId", "${messageId}")
        .ignore("/TestMessage/Timestamp");
}</programlisting>

        <para>Of course you can use the inline <emphasis>@ignore@</emphasis> placeholder in an external file resource, too.</para>
    </section>
    
    <section id="message-validation-elements">
        <title>Explicit message element validation</title>
        
        <para>In the previous sections we have seen how to validate whole message element structure with control message templates. All elements are validated
        and compared. In some cases this approach might be too extensive. Imagine the tester only needs to validate a small subset of message elements. The definition
        of control templates in combination with several ignore statements is not appropriate in this case. You would rather want
        to use explicit element validation.</para>
        
        <para><emphasis>XML DSL</emphasis></para>
        <programlisting>&lt;message&gt;
  &lt;validate path=&quot;/TestRequest/MessageId&quot; value=&quot;${messageId}&quot;/&gt;
  &lt;validate path=&quot;/TestRequest/VersionId&quot; value=&quot;2&quot;/&gt;
&lt;/message&gt;</programlisting>

        <para><emphasis>Java DSL</emphasis></para>
    <programlisting language="java">@CitrusTest
public void receiveMessageTest() {
    receive("helloServiceServer")
        .validate("/TestRequest/MessageId", "${messageId}")
        .validate("//VersionId", "2")
        .header("Operation", "sayHello");
}</programlisting>
        
        <para>Instead of comparing the whole message some message elements are validated explicitly over XPath. Citrus evaluates the XPath expression on the received message and
        compares the result value to the control value. The basic message structure as well as all other message elements are not included into this explicit validation.</para> 
        
        <note>
            <para>If this type of element validation is chosen neither &lt;payload&gt; nor &lt;data&gt; nor &lt;resource&gt; template definitions are allowed in Citrus XML test cases.</para>
        </note>
        
        <tip>
            <para>Citrus offers an alternative dot-notated syntax in order to walk through XML trees. In case you are not 
            familiar with XPath or simply need a very easy way to find your element inside the XML tree you might use this way. Every 
            element hierarchy in the XML tree is represented with a simple dot - for example:</para>
            
            <para><literal>TestRequest.VersionId</literal></para>
            
            <para>The expression will search the XML tree for the respective &lt;TestRequest&gt;&lt;VersionId&gt; element. Attributes
            are supported too. In case the last element in the dot-notated expression is a XML attribute the framework will automatically 
            find it.</para>
            
            <para>Of course this dot-notated syntax is very simple and might not be applicable for more complex tree navigation.
            XPath is much more powerful - no doubt. However the dot-notated syntax might help those of you that are not familiar with XPath.
            So the dot-notation is supported wherever XPath expressions might apply.</para>
        </tip>  
    </section>
    
    <section id="message-header-validation">
        <title>Validate the message header</title>
        
        <para>Now that we have validated the message payload in various ways we are now interested in validating the message header. This is simple as you have to
        define the header name and the control value that you expect. Just add the following header validation to your receiving action.</para>
        
        <para><emphasis>XML DSL</emphasis></para>
        <programlisting>&lt;header&gt;
    &lt;element name=&quot;Operation&quot; value=&quot;GetCustomer&quot;/&gt;
    &lt;element name=&quot;RequestTag&quot; value=&quot;${requestTag}&quot;/&gt;
&lt;/header&gt;</programlisting>

        <para><emphasis>Java DSL</emphasis></para>
    <programlisting language="java">@CitrusTest
public void receiveMessageTest() {
    receive("helloServiceServer")
        .header("Operation", "sayHello")
        .header("MessageId", "${messageId}");
}</programlisting>
        
        <para>Message headers are represented as name-value pairs. Each expected header element identified by its name has to be present in the received message. In addition
        to that the header value is compared to the given control value. If a header entry is not found by its name or the value does not fit accordingly Citrus will raise
        validation errors and the test case will fail.</para>
        
        <note>Sometimes message headers may not apply to the name-value pair pattern. For example SOAP headers can also contain XML fragments. Citrus supports these kind of
        headers too. Please see the SOAP chapter for more details.</note>
    </section>
    
    <section id="message-content-extract">
        <title>Saving message content to variables</title>
        
        <para>Imagine you receive a message in your test with some generated message identifier values. You have no chance to predict the identifier value
        because it was generated at runtime by a foreign application. You can ignore the value in order to protect your validation. But in many cases you might need to return
        this identifier in the respective response message or somewhat later on in the test. So we have to save the dynamic message content for reuse in later test steps.
        The solution is simple and very powerful. We can extract dynamic values from received messages and save those to test variables. Add this code to your message receiving action.</para>
        
        <para><emphasis>XML DSL</emphasis></para>
        <programlisting>&lt;extract&gt;
    &lt;header name=&quot;Operation&quot; variable=&quot;operation&quot;/&gt;
    &lt;message path=&quot;/TestRequest/VersionId&quot; variable=&quot;versionId&quot;/&gt;
&lt;/extract&gt;</programlisting>

        <para><emphasis>Java DSL</emphasis></para>
        <programlisting language="java">@CitrusTest
public void receiveMessageTest() {
    receive("helloServiceServer")
        .extractFromHeader("Operation", "operation")
        .extractFromPayload("//TestRequest/VersionId", "versionId");
        
    echo("Extracted operation from header is: ${operation}");
    echo("Extracted version from payload is: ${versionId}");
}</programlisting>
        
        <para>As you can see Citrus is able to extract both header and message payload content into test variables. It does not matter if you use new test variables
        or existing variables as target. The extraction will automatically create a new variable in case it does not exist. The time the variable was created
        all following test actions can access the test variables as usual. So you can reference the variable values in response messages or other test steps ahead.</para>
    </section>
    
    <section id="message-selector">
        <title>Message selectors</title>
        
        <para>The <emphasis>&lt;selector&gt;</emphasis> element inside the receiving action defines key-value pairs in order to 
        filter the messages being received. The filter applies to the message headers. This means that a receiver will
        only accept messages matching a header element value. In messaging applications the header information often holds message ids,
        correlation ids, operation names and so on. With this information given you can explicitly listen for messages that belong to your test case.
        This is very helpful to avoid receiving messages that are still available on the message destination.</para>
        
        <para>Lets say the tested software application keeps sending messages that belong to previous test cases. This could happen in retry 
        situations where the application error handling automatically tries to solve a communication problem that occurred
        during previous test cases. As a result a message destination (e.g. a JMS message queue) contains messages that are not valid any more for the currently 
        running test case. The test case might fail because the received message does not apply to the actual use case. So we will definitely run into validation errors
        as the expected message control values do not match.</para>
        
        <para>Now we have to find a way to avoid these problems. The test could filter the messages on a destination to only receive messages 
        that apply for the use case that is being tested. The Java Messaging System (JMS) came up with a message header selector that will 
        only accept messages that fit the expected header values.</para>
        
        <para>Let us have a closer look at a message selector inside a receiving action:</para>
        
        <para><emphasis>XML DSL</emphasis></para>
        <programlisting>&lt;selector&gt;
    &lt;element&gt; name="correlationId" value="Cx1x123456789"&lt;/element&gt;
    &lt;element&gt; name="operation" value="getOrders"&lt;/element&gt;
&lt;/selector&gt;</programlisting>

        <para><emphasis>Java DSL</emphasis></para>
        <programlisting language="java">@CitrusTest
public void receiveMessageTest() {
    receive("testServiceEndpoint")
        .selector("correlationId='Cx1x123456789' AND operation='getOrders'");
}</programlisting>
        
        <para>This example shows how message selectors work. The selector will only accept messages that meet the correlation id and the operation
        in the header values. All other messages on the message destination are ignored. The selector elements are automatically associated to 
        each other using the logical AND operator. This means that the message selector string would look like this: <emphasis>correlationId = 'Cx1x123456789' AND operation = 'getOrders'</emphasis>.</para>
        
        <para>Instead of using several elements in the selector you can also define a selector string directly which gives you more power in constructing the selection logic yourself. This way
        you can use <emphasis>AND</emphasis> logical operators yourself.</para>
        
        <programlisting>&lt;selector&gt;
    &lt;value&gt;
        correlationId = 'Cx1x123456789' AND operation = 'getOrders'
    &lt;/value&gt;
&lt;/selector&gt;</programlisting>
        
        <important>
            <para>In case you want to run tests in parallel message selectors become essential in your test cases. The different tests running 
            at the same time will steal messages from each other when you lack of message selection mechanisms.</para>
        </important>
        
        <important>
            <para>Previously only JMS message destinations offered support for message selectors! With Citrus version 1.2 we introduced message selector support for 
            Spring Integration message channels, too (see <xref linkend="message-channel-selector-support"/>).</para>
        </important>
    </section>
    
    <para>At this point you know the two most important test actions in Citrus. Sending and receiving actions will become the main components of your integration tests when dealing 
    with loosely coupled message based components in a enterprise application environment. It is very easy to create complex message flows, meaning a sequence of sending and receiving actions in your test case.
    You can replicate use cases and test your message exchange with extended message validation capabilities.</para>
  </section>
  
  <section id="validation-callback">
    <title>Validation callback</title>
    
    <para>The Java DSL offers some additional validation tricks and possibilities when dealing with messages that are sent and received over Citrus. One of them is the validation
    callback functionality. With this piece you can marshal received message payloads and code validation steps on Java objects.</para>
    
    <para><emphasis>Java DSL</emphasis></para>
    <programlisting language="java">@CitrusTest
public void receiveMessageTest() {
    receive(bookResponseEndpoint)
      .validationCallback(new MarshallingValidationCallback&lt;AddBookResponseMessage&gt;() {
          @Override
          public void validate(AddBookResponseMessage response, MessageHeaders headers) {
              Assert.isTrue(response.isSuccess());
          }
      });
}</programlisting>
    
    <para>By default the validation callback needs some XML unmarshaller implementation for transforming the XML payload to a Java object. Citrus will automatically search for the unmarshaller bean
    in your Spring application context if nothing specific is set. Of course you can also set the unmarshaller instance explicitly.</para>
    
    <para><emphasis>Java DSL</emphasis></para>
    <programlisting language="java">@Autowired
private Unmarshaller unmarshaller;

@CitrusTest
public void receiveMessageTest() {
    receive(bookResponseEndpoint)
        .validationCallback(new MarshallingValidationCallback&lt;AddBookResponseMessage&gt;(unmarshaller) {
            @Override
            public void validate(AddBookResponseMessage response, MessageHeaders headers) {
                Assert.isTrue(response.isSuccess());
            }
        });
}</programlisting>

    <para>Obviously working on Java objects is much more comfortable than using the XML String concatenation. This is why you can also use this feature
    when sending messages.</para>
    
    <para><emphasis>Java DSL</emphasis></para>
    <programlisting language="java">@Autowired
private Marshaller marshaller;

@CitrusTest
public void sendMessageTest() {
    send(bookRequestEndpoint)
            .payload(createAddBookRequestMessage("978-citrus:randomNumber(10)"), marshaller)
            .header("citrus_soap_action", "addBook");
}

private AddBookRequestMessage createAddBookRequestMessage(String isbn) {
    AddBookRequestMessage requestMessage = new AddBookRequestMessage();
    Book book = new Book();
    book.setAuthor("Foo");
    book.setTitle("FooTitle");
    book.setIsbn(isbn);
    book.setYear(2008);
    book.setRegistrationDate(Calendar.getInstance());
    requestMessage.setBook(book);
    return requestMessage;
}</programlisting>

    <para>The example above creates a <emphasis>AddBookRequestMessage</emphasis> object and puts this as payload to a send action. In combination with a marshaller instance Citrus is
    able to create a proper XML message payload then.</para>
  </section>
  
  <section id="groovy-utils">
    <title>Groovy utils for send and receive</title>
    
    <para>Groovy is a great JVM language and offers some nice and easy to use features for working with XML structures. You can use those in Citrus within the send and receive test actions in order
    to construct message payloads via Groovy scripts.</para>
    
    <section id="groovy-markupbuilder">
        <title>Groovy MarkupBuilder</title>
        
        <para>With the Groovy MarkupBuilder you can build XML message payloads in a simple way, without having to write the typical XML overhead.
        For example we use a Groovy script to construct the XML message to be sent out. Instead of a plain CDATA XML section or the nested payload XML data we write a Groovy script snippet. The Groovy MarkupBuilder
        generates the XML message payload with exactly the same result:</para>
        
        <para><emphasis>XML DSL</emphasis></para>
        <programlisting>&lt;send endpoint=&quot;helloServiceClient&quot;&gt;
    &lt;message&gt;
        &lt;builder type=&quot;groovy&quot;&gt;
            markupBuilder.TestMessage {
                    MessageId('${messageId}')
                    Timestamp('?')
                    VersionId('2')
                    Text('Hello Citrus!')
                }
            }
        &lt;/builder&gt;
        &lt;element path=&quot;/TestMessage/Timestamp&quot;
                    value=&quot;${createDate}&quot;/&gt;
    &lt;/message&gt;
    &lt;header&gt;
        &lt;element name=&quot;Operation&quot; value=&quot;sayHello&quot;/&gt;
        &lt;element name=&quot;MessageId&quot; value=&quot;${messageId}&quot;/&gt;
    &lt;/header&gt;
&lt;/send&gt;</programlisting>

        <para>We use the <emphasis>builder</emphasis> element with type <emphasis>groovy</emphasis> and the MarkupBuilder code is directly written to this element. As you can see from the example above, you can mix XPath
        and Groovy markup builder code. The MarkupBuilder syntax is very easy and follows the simple rule: <emphasis>markupBuilder.ROOT-ELEMENT{ CHILD-ELEMENTS }</emphasis>. However the tester has to follow some simple rules and
        naming conventions when using the Citrus MarkupBuilder extension:</para>
        
        <itemizedlist>
            <listitem>The MarkupBuilder is accessed within the script over an object named <literal>markupBuilder</literal>. The name of the custom root element follows with all its child elements.</listitem>
            <listitem>Child elements may be defined within curly brackets after the root-element (the same applies for further nested child elements)</listitem>
            <listitem>Attributes and element values are defined within round brackets, after the element name</listitem>
            <listitem>Attribute and element values have to stand within apostrophes (e.g. attribute-name: 'attribute-value')</listitem>
        </itemizedlist>
        
        <para>The Groovy MarkupBuilder script may also be used within receive actions as shown in the following listing:</para>
        
        <para><emphasis>XML DSL</emphasis></para>
        <programlisting>&lt;send endpoint=&quot;helloServiceClient&quot;&gt;
    &lt;message&gt;
        &lt;builder type=&quot;groovy&quot; file=&quot;classpath:com/consol/citrus/groovy/helloRequest.groovy&quot;/&gt;
    &lt;/message&gt;
&lt;/send&gt;

&lt;receive endpoint="helloServiceClient" timeout="5000"&gt;
    &lt;message&gt;
        &lt;builder type=&quot;groovy&quot;&gt;
            markupBuilder.TestResponse(xmlns: 'http://www.consol.de/schemas/samples/sayHello.xsd'){
                MessageId('${messageId}')
                CorrelationId('${correlationId}')
                User('HelloService')
                Text('Hello ${user}')
            }
        &lt;/builder&gt;
    &lt;/message&gt;
&lt;/receive&gt;</programlisting>
        
        <para>As you can see it is also possible to define the script as external file resource. In addition to that namespace support is given as normal attribute definition 
        within the round brackets after the element name.</para>
        
        <para>The MarkupBuilder implementation in Groovy offers great possibilities in defining message payloads. We do not need to write XML tag
        overhead and we can construct complex message payloads with Groovy logic like iterations and conditional elements. For detailed MarkupBuilder descriptions please see the
        official Groovy documentation.</para> 
    </section>

    <section id="groovy-xmlslurper">
        <title>Groovy XmlSlurper</title>

        <para>With the Groovy XmlSlurper you can easily validate XML message payloads without having to deal directly with XML. People who do not want to deal with XPath may 
        also like this validation alternative. The tester directly navigates through the message elements and uses simple code assertions in order to control the message content. 
        Here is an example how to validate messages with Groovy script:</para>

        <para><emphasis>XML DSL</emphasis></para>
        <programlisting>&lt;receive endpoint=&quot;helloServiceClient&quot; timeout=&quot;5000&quot;&gt;
    &lt;message&gt;
        &lt;validate&gt;
            &lt;script type=&quot;groovy&quot;&gt;
              assert root.children().size() == 4
              assert root.MessageId.text() == '${messageId}'
              assert root.CorrelationId.text() == '${correlationId}'
              assert root.User.text() == 'HelloService'
              assert root.Text.text() == 'Hello ' + context.getVariable("user")
            &lt;/script&gt;
        &lt;/validate&gt;
    &lt;/message&gt;
    &lt;header&gt;
        &lt;element name=&quot;Operation&quot; value=&quot;sayHello&quot;/&gt;
        &lt;element name=&quot;CorrelationId&quot; value=&quot;${correlationId}&quot;/&gt;
    &lt;/header&gt;
&lt;/receive&gt;</programlisting>

        <para><emphasis>Java DSL</emphasis></para>
        <programlisting language="java">@CitrusTest
public void receiveMessageTest() {
    receive("helloServiceClient")
        .validateScript("assert root.MessageId.text() == '${messageId}';" +
                        "assert root.CorrelationId.text() == '${correlationId}';")
        .header("Operation, "sayHello")
        .header("CorrelationId", "${correlationId}")
        .timeout(5000L);
}</programlisting>

        <para>The Groovy XmlSlurper validation script goes right into the message-tag instead of a XML control template or XPath validation. The Groovy script 
        supports Java <literal>assert</literal> statements for message element validation. The element navigation starts with the root element 
        reffered to as <literal>root</literal>. Based on this root element you can also access child elements and attributes. Just use the element names seperated 
        by a simple dot. Very easy! If you need the list of child elements use the <literal>children()</literal> function on any element. With the 
        <literal>text()</literal> function you get access to the element's text-value. The <literal>size()</literal> is very useful for validating the number of child 
        elements which completes the basic validation statements.</para>

        <para>As you can see from the example, we may use test variables within the validation script, too. Also not very surprising you may use external file resources
        as validaton scripts. The syntax looks like follows:</para>

        <para><emphasis>XML DSL</emphasis></para>
        <programlisting>&lt;receive endpoint=&quot;helloServiceClient&quot; timeout=&quot;5000&quot;&gt;
    &lt;message&gt;
        &lt;validate&gt;
          &lt;script type=&quot;groovy&quot; file=&quot;classpath:validationScript.groovy&quot;/&gt;
        &lt;/validate&gt;
    &lt;/message&gt;
    &lt;header&gt;
        &lt;element name=&quot;Operation&quot; value=&quot;sayHello&quot;/&gt;
        &lt;element name=&quot;CorrelationId&quot; value=&quot;${correlationId}&quot;/&gt;
    &lt;/header&gt;
&lt;/receive&gt;</programlisting>

        <para><emphasis>Java DSL</emphasis></para>
        <programlisting language="java">@CitrusTest
public void receiveMessageTest() {
    receive("helloServiceClient")
        .validateScript(new FileSystemResource("validationScript.groovy"))
        .header("Operation, "sayHello")
        .header("CorrelationId", "${correlationId}")
        .timeout(5000L);
}</programlisting>

        <note>You can use the Groovy validation script in combination with other validation types like XML tree comparison and XPath validation.</note>

        <tip>For further information on the Groovy XmlSlurper please see the official Groovy website and documentation</tip>
    </section>
  </section>
  
</chapter>
