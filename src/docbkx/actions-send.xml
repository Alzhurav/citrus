<?xml version="1.0" encoding="UTF-8"?>
<section id="actions-send">
    <title>Sending messages</title>

    <para>In a integration test scenario we want to trigger processes and call interface services on the system under test. In order to do this we need to be able to
    send messages to various message transports. Therefore the send message test action in Citrus is one of the most important test actions. First of all let us
    have a look at the Citrus message definition in Citrus:</para>

    <mediaobject>
        <imageobject role="fo">
            <imagedata align="center" width="200px" scale="100" fileref="figure_001.jpg" format="JPG" />
        </imageobject>

        <imageobject role="html">
            <imagedata align="center" display="block" fileref="figure_001.jpg" format="JPG" />
        </imageobject>
    </mediaobject>

    <para>A message consists of a message header (name-value pairs) and a message payload. Later in this section we will see different ways of constructing a message
    with payload and header values. But first of all let's concentrate on a simple sending message action inside a test case.</para>

    <para><emphasis>XML DSL</emphasis></para>
    <programlisting>&lt;testcase name=&quot;SendMessageTest&quot;&gt;
    &lt;description&gt;Basic send message example&lt;/description&gt;

    &lt;variables&gt;
        &lt;variable name=&quot;text&quot; value=&quot;Hello Citrus!&quot;/&gt;
        &lt;variable name=&quot;messageId&quot; value=&quot;Mx1x123456789&quot;/&gt;
    &lt;/variables&gt;

    &lt;actions&gt;
        &lt;send endpoint=&quot;helloServiceEndpoint&quot;&gt;
            &lt;message&gt;
                &lt;payload&gt;
                    &lt;TestMessage&gt;
                        &lt;Text&gt;${text}&lt;/Text&gt;
                    &lt;/TestMessage&gt;
                &lt;/payload&gt;
            &lt;/message&gt;
            &lt;header&gt;
                &lt;element name=&quot;Operation&quot; value=&quot;sayHello&quot;/&gt;
                &lt;element name=&quot;MessageId&quot; value=&quot;${messageId}&quot;/&gt;
            &lt;/header&gt;
        &lt;/send&gt;
    &lt;/actions&gt;
&lt;/testcase&gt;</programlisting>

    <para>The sample uses both header and payload as message parts to send. In both parts you can use variable definitions
    (see <emphasis>${text}</emphasis> and <emphasis>${messageId}</emphasis>). So first of all let us recap what variables do.
    Test variables are defined at the very beginning of the test case and are valid throughout all actions that take place in
    the test. This means that actions can simply reference a variable by the expression <literal>${variable-name}</literal>.</para>

    <tip>
        <para>Use variables wherever you can! At least the important entities of a test should be defined as variables at the
        beginning. The test case improves maintainability and flexibility when using variables.</para>
    </tip>

    <para>Now lets have a closer look at the sending action. The <emphasis>'endpoint'</emphasis> attribute might catch your attention first.
    This attribute references a message endpoint in Citrus configuration by name. As previously mentioned the message endpoint
    definition lives in a separate configuration file and contains the actual message transport settings. In this example the
    <emphasis>&quot;helloServiceEndpoint&quot;</emphasis> is referenced which is a message endpoint for sending out messages via
    JMS or HTTP for instance.</para>

    <para>The test case is not aware of any transport details, because it does not have to. The advantages are obvious: On the one hand multiple test
    cases can reference the message endpoint definition for better reuse. Secondly test cases are independent of message transport details.
    So connection factories, user credentials, endpoint uri values and so on are not present in the test case.</para>

    <para>In other words the <emphasis>&quot;endpoint&quot;</emphasis> attribute of the <emphasis>&lt;send&gt;</emphasis> element specifies
    which message endpoint definition to use and therefore where the message should go to. Once again all available message endpoints are
    configured in a separate Citrus configuration file. We will come to this later on. Be sure to always pick the right message endpoint type
    in order to publish your message to the right destination.</para>

    <para>If you do not like the XML language you can also use pure Java code to define the same test. In Java you would also make use of the message endpoint
    definition and reference this instance. The same test as shown above in Java DSL looks like this:</para>

    <para><emphasis>Java DSL</emphasis></para>
    <programlisting language="java">import org.testng.ITestContext;
import org.testng.annotations.Test;
import com.consol.citrus.annotations.CitrusTest;
import com.consol.citrus.dsl.testng.TestNGCitrusTestDesigner;

@Test
public class SendMessageTestDesigner extends TestNGCitrusTestDesigner {

    @CitrusTest(name = "SendMessageTest")
    public void sendMessageTest() {
        description("Basic send message example");

        variable("text", "Hello Citrus!");
        variable("messageId", "Mx1x123456789");

        send("helloServiceEndpoint")
                .payload("&lt;TestMessage&gt;" +
                    "&lt;Text&gt;${text}&lt;/Text&gt;" +
                    "&lt;/TestMessage&gt;")
                .header("Operation", "sayHello")
                .header("RequestTag", "${messageId}");
    }
}</programlisting>

    <para>Instead of using the XML tags for send we use methods from <emphasis>TestNGCitrusTestDesigner</emphasis> class. The same message endpoint
    is referenced within the send message action.</para>

    <para>Now that the message sender pattern is clear we can concentrate on how to specify the message content to be sent.
    There are several possibilities for you to define message content in Citrus:</para>

    <itemizedlist mark="opencircle">
        <listitem>
            <para><emphasis>message</emphasis>: This element constructs the message to be sent. There are several child elements available:</para>
            <itemizedlist mark="opencircle">
                <listitem>
                    <para><emphasis>payload</emphasis>: Nested XML payload as direct child node.</para>
                </listitem>
                <listitem>
                    <para><emphasis>data</emphasis>: Inline CDATA definition of the message payload</para>
                </listitem>
                <listitem>
                    <para><emphasis>resource</emphasis>: External file resource holding the message payload</para>
                    <para>The syntax would be: &lt;resource file="classpath:com/consol/citrus/messages/TestRequest.xml" /&gt;</para>
                    <para>The file path prefix indicates the resource type, so the file location is resolved either as file system resource (file:)
                        or classpath resource (classpath:).</para>
                </listitem>
                <listitem>
                    <para><emphasis>element</emphasis>: Explicitly overwrite values in the XML message payload using XPath. You can replace message content
                        with dynamic values before sending. Each &lt;element&gt; entry provides a &quot;path&quot; and &quot;value&quot; attribute. The &quot;path&quot;
                        gives a XPath expression evaluating to a XML node element or attribute in the message. The &quot;value&quot; can be a variable expression or any other
                        static value. Citrus will replace the value before sending the message.</para>
                </listitem>
            </itemizedlist>
        </listitem>
        <listitem>
            <para><emphasis>header</emphasis>: Defines a header for the message (e.g. JMS header information or SOAP header):</para>
            <itemizedlist mark="opencircle">
                <listitem>
                    <para><emphasis>element</emphasis>: Each header receives a &quot;name&quot; and &quot;value&quot;. The &quot;name&quot; will be the
                        name of the header entry and &quot;value&quot; its respective value. Again the usage of variable expressions as value is supported here, too.</para>
                </listitem>
            </itemizedlist>
        </listitem>
    </itemizedlist>

    <para>The most important thing when dealing with sending actions is to prepare the message payload and header. You are able to construct the message payload either by
    nested XML child nodes (payload), as inline CDATA (&lt;data&gt;) or external file (&lt;resource&gt;). Before sending takes place you can explicitly overwrite some message
    values explicitly. You can think of overwriting specific message elements with variable values for instance. The example above uses the variable ${text} directly in the
    XML payload definition. In addition to that you can use XPath expressions for overwriting message contents before sending. The two approaches of overwriting message
    elements before sending can coexist simultaneously.</para>

    <para>The message header is part of our duty of defining proper messages, too. So Citrus uses name-value pairs like &quot;Operation&quot; and &quot;MessageId&quot; in the
    example above to set message header entries. Depending on what message endpoint is used and which message transport underneath the header values will be shipped in different ways.
    In JMS the headers go to the header section of the message, in Http we set mime headers accordingly, in SOAP we can access the SOAP header elements and so on. Citrus aims to do
    the hard work for you. So Citrus knows how to set headers on different message transports.</para>

    <note>
        <para>Sometimes the nested XML message payload elements may cause XSD schema validation rule violations. This is because of variable values not fitting the XSD schema rules
        for example. In this scenario you could also use simple CDATA sections as payload data. In this case you need to use the <literal>&lt;data&gt;</literal> element in contrast
        to the <literal>&lt;payload&gt;</literal> element that we have used in our examples so far.</para>

        <para>With this alternative you can skip the XML schema validation from your IDE at design time. Unfortunately you will loose the XSD auto completion features many XML editors
        offer when constructing your payload. See following example for usage explanation:</para>

        <programlisting>&lt;testcase name=&quot;sendMessageTest&quot;&gt;
    &lt;actions&gt;
        &lt;send endpoint=&quot;helloServiceEndpoint&quot;&gt;
            &lt;message&gt;
                &lt;data&gt;
                    &lt;![CDATA[
                        &lt;hlo:HelloRequest xmlns:hlo=&quot;http://www.consol.de/schemas/samples/sayHello.xsd&quot;&gt;
                            &lt;hlo:Body&gt;Hello Citrus!&lt;/hlo:Body&gt;
                        &lt;/hlo:HelloRequest&gt;
                    ]]&gt;
                &lt;/data&gt;
            &lt;/message&gt;
            ...
        &lt;/send&gt;
    &lt;/actions&gt;
&lt;/testcase&gt;</programlisting>

        <para>This alternative works for receiving message actions, too. We will see this in the next sections.</para>
    </note>

    <para>This is basically how to send messages in Citrus. The test case is responsible for constructing the message content while the predefined message endpoint holds transport specific
    settings. Test cases reference endpoint components to publish messages to the outside world. The variable support in message payload and message header
    enables you to add dynamic values before sending out the message.</para>
</section>