<?xml version="1.0" encoding="UTF-8"?>
<section id="validation-xml">
    <title>Xml message validation</title>

    <para>XML is a very common message format especially in the SOAP WebServices and JMS messaging world. Citrus provides XML message validator implementations that
        are able to compare XML message structures. The validator will notice differences in the XML message structure and supports XML namespaces, attributes and XML schema
        validation.</para>

    <section id="validation-xml-payload">
        <title>XML payload validation</title>

        <para>Once Citrus has received a message the tester can validate the message contents in various ways. First of all the tester can compare
            the whole message payload to a predefined control message template.</para>

        <para>The receiving action offers following elements for control message templates:</para>
        <itemizedlist mark="opencircle">
            <listitem>
                <para><emphasis>&lt;payload&gt;</emphasis>: Defines the message payload as nested XML message template. The whole message payload is defined
                    inside the test case.</para>
            </listitem>
            <listitem>
                <para><emphasis>&lt;data&gt;</emphasis>: Defines an inline XML message template as nested CDATA. Slightly different to the payload variation as
                    we define the whole message payload inside the test case as CDATA section.</para>
            </listitem>
            <listitem>
                <para><emphasis>&lt;resource&gt;</emphasis>: Defines an expected XML message template via external file resources. This time the payload is loaded
                    at runtime from the external file.</para>
            </listitem>
        </itemizedlist>

        <para>Both ways inline payload definition or external file resource give us a control message template that the test case expects to arrive. Citrus uses this
            control template for extended message comparison. All elements, namespaces, attributes and node values are validated in this comparison. When using XML message payloads
            Citrus will navigate through the whole XML structure validating each element and its content. Same with JSON payloads.</para>

        <para>Only in case received message and control message are equal to each other as expected the message validation will pass. In case differences occur Citrus gives
            detailed error messages and the test case fails.</para>

        <para>The control message template is not necessarily very static. Citrus supports various ways to add dynamic message content on the one side and on the other side Citrus can
            ignore some elements that are not part of message comparison (e.g. when generated content or timestamps are part of the message content). The tester can enrich the expected
            message template with test variables or ignore expressions so we get a more robust validation mechanism. We will talk about this in the next sections to come.</para>

        <para>When using the Citrus Java DSL you will face a verbose message payload definition. This is because Java does not support multiline character sequence values as Strings.
            We have to use verbose String concatenation when constructing XML message payload contents for instance. In addition to that reserved characters like quotes must be escaped
            and line breaks must be explicitly added. All these impediments let me suggest to use external file resources in Java DSL when dealing with large complex message payload data.
            Here is an example:</para>

        <para><emphasis>Java DSL</emphasis></para>
        <programlisting language="java">@CitrusTest
public void receiveMessageTest() {
    receive("helloServiceServer")
        .payload(new ClassPathResource("com/consol/citrus/message/data/TestRequest.xml"))
        .header("Operation", "sayHello")
        .header("MessageId", "${messageId}");
}</programlisting>
    </section>

    <section id="validation-xml-header">
        <title>XML header validation</title>

        <para>Now that we have validated the message payload in various ways we are now interested in validating the message header. This is simple as you have to
            define the header name and the control value that you expect. Just add the following header validation to your receiving action.</para>

        <para><emphasis>XML DSL</emphasis></para>
        <programlisting>&lt;header&gt;
    &lt;element name=&quot;Operation&quot; value=&quot;GetCustomer&quot;/&gt;
    &lt;element name=&quot;RequestTag&quot; value=&quot;${requestTag}&quot;/&gt;
&lt;/header&gt;</programlisting>

        <para><emphasis>Java DSL</emphasis></para>
        <programlisting language="java">@CitrusTest
public void receiveMessageTest() {
    receive("helloServiceServer")
        .header("Operation", "sayHello")
        .header("MessageId", "${messageId}");
}</programlisting>

        <para>Message headers are represented as name-value pairs. Each expected header element identified by its name has to be present in the received message. In addition
            to that the header value is compared to the given control value. If a header entry is not found by its name or the value does not fit accordingly Citrus will raise
            validation errors and the test case will fail.</para>

        <note>Sometimes message headers may not apply to the name-value pair pattern. For example SOAP headers can also contain XML fragments. Citrus supports these kind of
            headers too. Please see the SOAP chapter for more details.</note>
    </section>

    <section id="validation-xml-ignore">
        <title>Ignore XML elements</title>

        <para>Some elements in the message payload might not apply for validation at all. Just think of communication timestamps an dynamic values inside a
            message:</para>

        <para>The timestamp value in our next example will dynamically change from test run to test run and is hardly predictable for the tester, so lets ignore it in validation.</para>

        <para><emphasis>XML DSL</emphasis></para>
        <programlisting> &lt;message&gt;
    &lt;payload&gt;
        &lt;TestMessage&gt;
            &lt;MessageId&gt;${messageId}&lt;/MessageId&gt;
            &lt;Timestamp&gt;2001-12-17T09:30:47.0Z&lt;/Timestamp&gt;
            &lt;VersionId&gt;@ignore@&lt;/VersionId&gt;
        &lt;/TestMessage&gt;
    &lt;/payload&gt;
    &lt;ignore path=&quot;/TestMessage/Timestamp&quot;/&gt;
&lt;/message&gt;</programlisting>

        <para>Although we have given a static timestamp value in the payload data the element is ignored during validation as the ignore XPath expression matches the element. In addition to that
            we also ignored the version id element in this example. This time with an inline <emphasis>@ignore@</emphasis> expression. This is for those of you that do not like XPath. As a result the
            ignored message elements are automatically skipped when Citrus compares and validates message contents and do not break the test case.</para>

        <para>When using the Java DSL the <emphasis>@ignore@</emphasis> placeholder as well as XPath expressions can be used seamlessly. Here is an example of that:</para>

        <para><emphasis>Java DSL</emphasis></para>
        <programlisting language="java">@CitrusTest
public void receiveMessageTest() {
    receive("helloServiceServer")
        .payload(new ClassPathResource("com/consol/citrus/message/data/TestRequest.xml"))
        .header("Operation", "sayHello")
        .header("MessageId", "${messageId}")
        .ignore("/TestMessage/Timestamp");
}</programlisting>

        <para>Of course you can use the inline <emphasis>@ignore@</emphasis> placeholder in an external file resource, too.</para>
    </section>

    <section id="groovy-xmlslurper">
        <title>Groovy XML validation</title>

        <para>With the Groovy XmlSlurper you can easily validate XML message payloads without having to deal directly with XML. People who do not want to deal with XPath may
            also like this validation alternative. The tester directly navigates through the message elements and uses simple code assertions in order to control the message content.
            Here is an example how to validate messages with Groovy script:</para>

        <para><emphasis>XML DSL</emphasis></para>
        <programlisting>&lt;receive endpoint=&quot;helloServiceClient&quot; timeout=&quot;5000&quot;&gt;
    &lt;message&gt;
        &lt;validate&gt;
            &lt;script type=&quot;groovy&quot;&gt;
                assert root.children().size() == 4
                assert root.MessageId.text() == '${messageId}'
                assert root.CorrelationId.text() == '${correlationId}'
                assert root.User.text() == 'HelloService'
                assert root.Text.text() == 'Hello ' + context.getVariable("user")
            &lt;/script&gt;
        &lt;/validate&gt;
    &lt;/message&gt;
    &lt;header&gt;
        &lt;element name=&quot;Operation&quot; value=&quot;sayHello&quot;/&gt;
        &lt;element name=&quot;CorrelationId&quot; value=&quot;${correlationId}&quot;/&gt;
    &lt;/header&gt;
&lt;/receive&gt;</programlisting>

        <para><emphasis>Java DSL</emphasis></para>
        <programlisting language="java">@CitrusTest
public void receiveMessageTest() {
    receive("helloServiceClient")
        .validateScript("assert root.MessageId.text() == '${messageId}';" +
                        "assert root.CorrelationId.text() == '${correlationId}';")
        .header("Operation, "sayHello")
        .header("CorrelationId", "${correlationId}")
        .timeout(5000L);
}</programlisting>

        <para>The Groovy XmlSlurper validation script goes right into the message-tag instead of a XML control template or XPath validation. The Groovy script
            supports Java <literal>assert</literal> statements for message element validation. The element navigation starts with the root element
            reffered to as <literal>root</literal>. Based on this root element you can also access child elements and attributes. Just use the element names seperated
            by a simple dot. Very easy! If you need the list of child elements use the <literal>children()</literal> function on any element. With the
            <literal>text()</literal> function you get access to the element's text-value. The <literal>size()</literal> is very useful for validating the number of child
            elements which completes the basic validation statements.</para>

        <para>As you can see from the example, we may use test variables within the validation script, too. Also not very surprising you may use external file resources
            as validaton scripts. The syntax looks like follows:</para>

        <para><emphasis>XML DSL</emphasis></para>
        <programlisting>&lt;receive endpoint=&quot;helloServiceClient&quot; timeout=&quot;5000&quot;&gt;
    &lt;message&gt;
        &lt;validate&gt;
            &lt;script type=&quot;groovy&quot; file=&quot;classpath:validationScript.groovy&quot;/&gt;
        &lt;/validate&gt;
    &lt;/message&gt;
    &lt;header&gt;
        &lt;element name=&quot;Operation&quot; value=&quot;sayHello&quot;/&gt;
        &lt;element name=&quot;CorrelationId&quot; value=&quot;${correlationId}&quot;/&gt;
    &lt;/header&gt;
&lt;/receive&gt;</programlisting>

        <para><emphasis>Java DSL</emphasis></para>
        <programlisting language="java">@CitrusTest
public void receiveMessageTest() {
    receive("helloServiceClient")
        .validateScript(new FileSystemResource("validationScript.groovy"))
        .header("Operation, "sayHello")
        .header("CorrelationId", "${correlationId}")
        .timeout(5000L);
}</programlisting>

        <note>You can use the Groovy validation script in combination with other validation types like XML tree comparison and XPath validation.</note>

        <tip>For further information on the Groovy XmlSlurper please see the official Groovy website and documentation</tip>
    </section>

</section>